(in-package #:advent-of-code)

(defun read-hands-and-bids ()
  (loop for l in (read-input-file-as-lines "inputs/2023/day7")
        collect (register-groups-bind (hand
                                       (#'parse-integer bid))
                    ("(.*) (.*)" l)
                  (list hand bid))))

(defun hand-type (original-hand)
  (labels ((is-group-of-5 (g) (= 5 (length g)))
           (is-group-of-4 (g) (= 4 (length g)))
           (is-group-of-3 (g) (= 3 (length g)))
           (is-group-of-2 (g) (= 2 (length g))))
    (let* ((hand (copy-seq original-hand))
           (grouped-hand (serapeum:runs (sort hand #'char<))))
      (cond ((some #'is-group-of-5 grouped-hand) :five-of-a-kind)
            ((some #'is-group-of-4 grouped-hand) :four-of-a-kind)
            ((and (some #'is-group-of-3 grouped-hand)
                  (some #'is-group-of-2 grouped-hand))
             :full-house)
            ((and  (= 1 (count-if #'is-group-of-3 grouped-hand))
                   (= 0 (count-if #'is-group-of-2 grouped-hand)))
             :three-of-a-kind)
            ((= 2 (count-if #'is-group-of-2 grouped-hand))
             :two-pair)
            ((and  (= 1 (count-if #'is-group-of-2 grouped-hand))
                   (= 0 (count-if #'is-group-of-3 grouped-hand)))
             :one-pair)
            ((= 5 (length grouped-hand)) :high-card)))))

(defun hand-type> (hand1-type hand2-type)
  (let ((hand-type-values '((:five-of-a-kind . 7)
                            (:four-of-a-kind . 6)
                            (:full-house . 5)
                            (:three-of-a-kind . 4)
                            (:two-pair . 3)
                            (:one-pair . 2)
                            (:high-card . 1))))
    (> (cdr (assoc hand1-type hand-type-values))
       (cdr (assoc hand2-type hand-type-values)))))

(defun hand-convert-lexi (hand)
  (let ((card-values '((#\A . #\M)
                       (#\K . #\L)
                       (#\Q . #\K)
                       (#\J . #\J)
                       (#\T . #\I)
                       (#\9 . #\H)
                       (#\8 . #\G)
                       (#\7 . #\F)
                       (#\6 . #\E)
                       (#\5 . #\D)
                       (#\4 . #\C)
                       (#\3 . #\B)
                       (#\2 . #\A))))
    (coerce (loop for c across hand
                  collect (cdr (assoc c card-values)))
            'string)))

(defun hand> (h1 h2)
  (let ((h1-type (hand-type h1))
        (h2-type (hand-type h2)))
    (or (hand-type> h1-type h2-type)
        (and (eql h1-type h2-type)
             (string> (hand-convert-lexi h1)
                      (hand-convert-lexi h2))))))

(defun aoc2023/day7/solution1 ()
  (let ((hands-and-bids (read-hands-and-bids)))
    (reduce #'+
            (loop for rank from 1
                  for (hand bid) in (reverse (sort hands-and-bids #'hand> :key #'first))
                  collect (* bid rank)))))

(defun aoc2023/day7/solution2 ()
  )
